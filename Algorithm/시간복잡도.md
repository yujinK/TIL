### 시간복잡도

---

**알고리즘의 분석**

- 알고리즘의 <u>자원(resource) 사용량</u>을 분석
  - 모든 경우에 적용할 수 있는 보편적인 기준
  - 비교적 쉽게 정량화 할 수 있음
- 자원 = 실행 시간, 메모리, 저장장치, 통신 등



**시간복잡도(time complexity)**

- 실행시간은 실행환경에 따라 달라짐
- 실행 시간을 측정하는 대신 <u>연산의 실행 횟수</u>를 카운트
- 연산의 실행 횟수는 <u>입력 데이터의 크기에 관한 함수</u>로 표현
  - n에 대한 함수 ex.) n, n², 2n, 2n+3, ...
- 데이터의 크기가 같더라도 <u>실제 데이터</u>에 따라서 달라짐
  - 대표값을 가지고 표현
  - 최악의 경우 시간복잡도 (worst-case analysis)
    - 많은 사용 why? 평균 시간복잡도 분석이 어렵기 때문
  - 평균 시간복잡도 (average-case analysis)



**점근적(Asymptotic) 분석**

- 어떤 연산의 실행횟수에서 정확한 분석이 아닌 최고차항만 남기고 무시
  - ex.) n(n-1)/2 + 5 = O(n²)
- O-표기(Order of n², Big-O of n²) : Big-O notation
- Θ-표기(Theta)
- 점근적 분석법이 사용되는 이유 
  - 상대적으로 간단
  - 알고리즘의 실행환경에 비의존적
  - 유일한 분석법도 아니고 가장 좋은 분석법도 아님
  - 절대적인 분석법 X
  - 범용적인 분석법



**점근적 표기법**

- 알고리즘에 포함된 연산들의 실행 횟수를 표기하는 하나의 기법
- 최고차항의 차수만으로 표시
- 따라서 가장 자주 실행되는 연산 혹은 문장의 실행횟수를 고려하는 것으로 충분



**Common Growth Rate**

<img src="https://user-images.githubusercontent.com/42233535/54971415-b0846c00-4fc9-11e9-9cdb-e3233bf635c0.png">

<img src="https://user-images.githubusercontent.com/42233535/54971418-b2e6c600-4fc9-11e9-90f9-8bc40f31fef0.png">

<img src="https://user-images.githubusercontent.com/42233535/54971420-b4b08980-4fc9-11e9-9350-b7f312b929cf.png">

- 정렬 알고리즘들 보통 O(*n* log *n*)
- O(1) ~ O(n³)의 다항함수와 2ⁿ의 지수함수 사이에는 <u>엄청난 차이</u>가 나게 됨
- O(1) ~ O(n!)으로 진행될수록 알고리즘의 실행 시간이 증가

