## 액티비티(Activity)

- 애플리케이션 구성 요소

- 화면 제공

- 하나의 애플리케이션은 여러 개의 액티비티로 구성되고 그 중 하나의 액티비티가 "주요" 액티비티로 지정됨

- "주요" 액티비티는 사용자가 애플리케이션을 처음 실행할 때 표시됨

- 액티비티들은 스택(백 스택)에 저장됨

  <img src="https://user-images.githubusercontent.com/42233535/56702867-31f22a00-6741-11e9-8dc5-c60417c62509.png">

  - 액티비티가 시작되면 스택에 push, 액티비티가 소멸되면 스택에서 pop (후입선출, LIFO)

  

  <img src="https://user-images.githubusercontent.com/42233535/56702981-bf357e80-6741-11e9-933f-caa6c84b917f.png">

  - 작업(Task) = 하나의 잘 짜여진 단위, 액티비티 컬렉션
  - 작업의 모든 액티비티는 백그라운드에 있는 동안은 중단되지만, 해당 작업에 대한 백 스택은 그대로 유지 (포커스만 잃는 것)
  - 작업이 포그라운드로 돌아오면 사용자가 이전에 하던 일 계속 가능 (스택 맨 위에 있는 액티비티가 재개됨)
  - cf.) 여러 개의 작업을 백그라운드에 한꺼번에 대기시킬 수 있음. 하지만, 사용자가 수많은 백그라운드 작업을 동시에 실행하면 <u>시스템이 메모리를 복원하기 위해 백그라운드 액티비티를 소멸</u>시키기 시작할 수 있고, 그러면 액티비티 상태가 손실됨 = 시스템이 이 액티비티를 재개하는 것이 아닌 재생성함 (작업 내용 보존을 위해 액티비티의 onSaveInstanceState() 콜백 메서드 구현)

  

  <img src="https://user-images.githubusercontent.com/42233535/56703369-71ba1100-6743-11e9-8fe2-c8302ca8f9d3.png">

  - 백 스택의 액티비티는 재정렬 X
  - 애플리케이션에서 사용자에게 하나 이상의 액티비티로부터 특정 액티비티를 시작하도록 허용하는 경우, 해당 액티비티의 새 인스턴스가 생성되어 스택으로 푸시 (해당 액티비티의 기존 인스턴스를 맨 위로 가져오는 것 X) = 여러 번 인스턴스화 가능

- 액티비티의 상태 변경은 액티비티의 생명 주기 콜백 메서드를 통해 알려짐



### 액티비티 생성

- Activity의 서브클래스 생성
- 액티비티 생명 주기의 다양한 상태 간 액티비티가 전환될 때 시스템이 호출하는 콜백 메서드 구현
  - onCreate()
    - 반드시 구현
    - 시스템은 액티비티를 생성할 때 이 메서드 호출
    - 액티비티의 필수 구성 요소 초기화
    - setContentView() 호출해야 액티비티의 사용자 인터페이스 레이아웃 정의
  - onPause()
    - 사용자가 액티비티를 떠난다는 첫 번째 신호 (항상 액티비티가 소멸 중이라는 뜻은 아님)
    - 현재 사용자 세선을 넘어서 지속되어야 하는 변경 사항을 커밋하려면 이곳에서 진행



### 사용자 인터페이스 구현

- 한 액티비티에 대한 사용자 인터페이스는 뷰 계층 - View 클래스에서 파생된 객체가 제공

- 위젯 : 화면에 시각적(및 대화형) 요소를 제공하는 뷰

  ex.) 버튼, 텍스트 필드, 체크박스 등

- 레이아웃 : ViewGroup에서 파생된 뷰

  ex.) LinearLayout, ConstraintLayout 등

- 뷰를 사용하여 레이아웃을 정의하는 가장 보편적인 방식은 애플리케이션 리소스에 저장된 XML 레이아웃 파일을 사용하는 것



### 매니페스트에서 액티비티 선언

- 시스템에서 액티비티에 액세스할 수 있게 하려면 매니페스트 파일에 선언
- `<application>` 요소 하위 항목에 `<activity>` 요소 추가
- android:name
  - 필수 특성
  - 액티비티의 클래스 이름 지정
  - 애플리케이션 게시 후 이름 변경 불가
- 인텐트 필터 사용
  - `<intent-filter>` 
  - 다른 애플리케이션 구성 요소가 이를 활성화하는 방법을 선언
  - 다른 애플리케이션에서 사용할 수 없게 하고자 하는 액티비티에는 인텐트 필터 X -> 명시적인 인텐트 사용



### 액티비티 시작

- `startActivity()` 에 Intent 전달
- Intent는 시작하고자 하는 액티비티나 수행하고자 하는 작업의 유형 설명



### 결과에 대한 액티비티 시작

- `startActivityForResult()`
- `onActivityResult()`



### 액티비티 종료

- `finish()` : 해당 액티비티 종료
- `finishActivity()` : 이전에 시작한 액티비티 종료



### 액티비티 수명 주기 관리

- 액티비티의 기본적인 세 가지 상태
  1. 재개됨(Resumed) = 실행 중
     - 액티비티가 화면 포그라운드에 있고 사용자 포커스를 가짐
  2. 일시정지됨(Paused)
     - 다른 액티비티가 이 액티비티 위에 표시되어 있으며 해당 액티비티는 부분적으로 투명하거나 전체 화면을 덮지 않는 상태
     - Activity 객체가 메모리에 보관되어 있고, 모든 상태 및 멤버 정보를 유지하며, 창 관리자에 붙어있는 상태로 유지되지만 메모리가 부족한 경우 시스템이 중단시킬 수 있음
  3. 정지됨(Stopped)
     - 액티비티가 다른 액티비티에 완전히 가려진 상태 (백그라운드에 위치함)
     - Paused 상태와 유사하지만 창 관리자에 붙어있지 않음
     - 더 이상 사용자에게 표시되지 않으며 다른 곳에 메모리가 필요하면 시스템이 종료시킬 수 있음



### 수명 주기 콜백 구현

- 수명 주기 메서드를 구현하려면, 항상 슈퍼클래스 구현을 호출한 다음에만 다른 작업을 시작할 수 있음
- 액티비티 전체 수명
  - onCreate() ~ onDestroy()
- 액티비티 가시적 수명
  - onStart() ~ onStop()
  - 사용자가 액티비티를 화면에서 보고 이와 상호작용할 수 있음
  - 시스템은 액티비티의 전체 수명 내내 onStart() 및 onStop()을 여러 번 호출할 수 있으며, 이때 액티비티는 사용자에게 표시되었다 숨겨지는 상태를 오가게 됨
- 액티비티 전경 수명
  - onResume() ~ onPause()
  - 이 액티비티가 화면에서 다른 모든 액티비티 앞에 표시되며 사용자 입력도 여기에 집중됨
  - 이 상태는 자주 전환될 수 있으므로, 이 두 메서드의 코드는 상당히 가벼워야 함



<img src="https://user-images.githubusercontent.com/42233535/56712840-e94f6680-676a-11e9-9d51-cbd66151cefb.png">

- 시스템이 메서드가 반환된 후 액티비티 코드의 다른 줄을 실행하지 않고도 언제든 이 액티비티를 호스팅하는 프로세스를 중단시킬 수 있는 메서드 : onPause(), onStop(), onDestroy()
- 시스템이 비상 시에 메모리를 복구해야 할 경우 onStop(), onDestroy()는 호출되지 않을 수도 있음
- 중요한 영구적 데이터를 보관하기 위해 작성하는 경우 onPause() 사용



### 액티비티 상태 저장

- `onSaveInstanceState()`
  - 액티비티 상태에 관한 중요한 정보 보존
  - 액티비티에 관한 정보를 key-value로 저장할 수 있는 `Bundle`을 메서드에 전달
- 시스템이 애플리케이션 프로세스를 종료하고 사용자가 액티비티로 다시 돌아오면, 시스템이 액티비티를 다시 생성하고 Bundle을 `onCreate()`와 `onRestoreInstanceState()`에게 전달



<img src="https://user-images.githubusercontent.com/42233535/56715255-1b17fb80-6772-11e9-9d8c-1a8879d43fc2.png">

- 상태를 저장할 필요가 없는 경우도 있으므로 액티비티가 소멸되기 전에 onSaveInstanceState()가 호출된다는 보장은 없음 ex.)사용자가 명시적으로 액티비티를 닫기 위해 Back버튼을 눌러 액티비티를 떠나는 경우
- 시스템이 onSaveInstanceState()를 호출하는 경우, `onStop()` 전에 호출하는 것이 일반적이며 `onPause()` 전에 호출할 가능성도 높음
- onSaveInstanceState()의 기본 구현이 UI 상태를 저장, 추가 상태 정보를 저장하기 위해 이 메서드를 재정의하려면 작업을 하기 전 항상 onSaveInstanceState()의 슈퍼클래스 구현을 호출 (= onRestoreInstanceSate()도 동일)
- onSaveInstanceState()의 호출 보장되지 않음. 영구적인 데이터를 저장하려면 `onPause()` 사용



### 구성 변경 처리

- 몇몇 기기 구성은 런타임 중에 변경될 수 있음 (ex. 화면 방향, 키보드 가용성 및 언어 등)
- 기기 구성 변경이 발생하면 Android는 실행 중인 액티비티를 다시 생성 (시스템이 onDestroy()를 호출하고 즉시 onCreate()를 호출)



### 액티비티 조정

- 액티비티 A가 액티비티 B를 시작할 때 발생하는 작업 순서

  1. 액티비티 A의 onPause() 메서드 실행
  2. 액티비티 B의 onCreate(), onStart(), onResume() 메서드 순차적 실행
  3. 액티비티 A가 더 이상 화면에 표시되지 않는 경우 onStop() 메서드 실행

  ∴ 첫 번째 액티비티가 중단될 때 데이터베이스에 내용을 작성해서 다음 액티비티가 그 내용을 읽을 수 있도록 하려면, 데이터베이스에 onPause() 중에 쓰기 작업을 해야 함
