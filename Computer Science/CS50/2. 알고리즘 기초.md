### 2. 알고리즘 기초

#### Topic1: 입력한 자료를 출력하려면 어떤 과정이 필요할까요?

> Keyword
>
> - 알고리즘
> - 정확성
> - 효율성



**알고리즘**

- 컴퓨팅 : 입력을 받아 그 입력을 처리한 후 출력하는 과정
- **알고리즘** 
  - 입력에서 받은 자료를 출력형태로 만드는 처리 과정
  - **입력값을 출력값의 형태로 바꾸기 위해 어떤 명령들이 수행되어야 하는지에 대한 규칙들의 순서적 나열**



**정확한 알고리즘 (정확성)**

``````pseudocode
pick up phone book
open to first page of phone book
look at names
if "Smith" is among names
	call Mike
else if not at end of book
	flip to next page
	go to line3
else
	give up
``````

- 알고리즘의 평가 기준 : <u>**정확성, 효율성**</u>
- **효율성** : 작업을 완료하기까지 얼마나 시간과 노력을 덜 들일 수 있는지에 대한 척도
- ex) 한 번에 한 페이지씩 -> 한 번에 두 페이지씩



**효율적인 알고리즘 (효율성)**

``````pseudocode
pick up phone book
open to middle of phone book
look at names
if "Smith" is among names
	call Mile
else if "Smith" is earlier in book
	open to middle of left half of book
	go to line3
else if "Smith" is later in book
	open to middle of right half of book
	go to line3
else
	give up
``````

- 이진탐색 알고리즘 : 반씩 나누어가며 탐색



---

#### Topic2: 알고리즘을 이해하기 쉽게 표현하는 방법이 있을까요?

> Keyword
>
> - 프로그래밍 언어
> - 의사 코드
> - 할당
> - 들여쓰기



**의사 코드**

- 프로그래밍 언어
  - 기계가 알아들을 수 있도록 명령을 내리기 위해 사용되는 언어
  - 특정한 문법에 의해 작성
- 의사 코드
  - 프로그래밍 언어보다 문법적 제약을 적게 받음
  - 알고리즘 표현에 많이 사용



**의사 코드의 예시**

``````pseudocode
let n = 0
for each person in room
	set n = n + 1
``````

- 할당 : 이름을 부여하고 0 값을 넣어주는 것 (line 1)
- 들여쓰기 : 어떤 코드 블록이 어떤 문장에 포함되는지 알 수 있도록 함



**의사 코드의 요소**

- 값 할당
- 반복문
- 조건문



---

#### Topic3: 자료를 맨 처음부터 하나씩 비교하면서 찾는 방법은 무엇이라고 하나요?

> Keyword
>
> - 선형 탐색



**선형 탐색**

원하는 원소가 발견될 때까지 처음부터 마지막 자료까지 차례대로 탐색



**효율성 그리고 비효율성**

- 선형 탐색 알고리즘
  - 정확하지만 아주 효율적이지 못한 방법
  - 최악의 경우(찾고자 하는 자료가 맨 마지막 or 리스트 안에 없는 경우) 리스트의 모든 원소를 확인 -> n번 실행
  - 자료가 정렬되어 있지 않거나 그 어떤 정보도 없이 하나씩 찾아야 하는 경우에 유용



---

#### Topic4: 인접한 두 개의 자료를 차례로 비교하면서 정렬하는 것을 무엇이라고 하나요?

> Keyword
>
> - 버블 정렬
> - 배열



**버블 정렬**

- 정렬 알고리즘 중 하나
- 두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬
- 버블처럼 큰 값이 떠오른다



**실행**

<img src="https://user-images.githubusercontent.com/42233535/54729095-ee962000-4bc4-11e9-9b9c-7d6e6789eed2.png">

<img src="https://user-images.githubusercontent.com/42233535/54729103-f0f87a00-4bc4-11e9-98ad-80cd74480712.png">

- 버블 정렬은 배열 안에 들어있는 <u>두 개의 인접한 수를 비교하고 만약 순서에 맞지 않는다면 교환</u>해주는 방식으로 작동

  ​	1) 제일 먼저 배열 안에서 5와 1을 비교. 5 > 1 swap

  ​	2) 5와 6를 비교

  ​	3) 6과 2를 비교. 6 > 2 swap

  ​	4) 반복
- n개의 원소에 대해서 버블 정렬을 한 번 수행할 때마다 n번째 원소가 제자리를 찾게 됨

  - 다음 정렬에서는 n-1개의 원소 정렬



**정렬된 배열**

- 버블 정렬은 수행 한 번 만에 모든 원소가 정렬되는 것을 보장하지 않음
- 최악의 경우 n개의 요소를 정렬하기 위해서는 n-1번 실행
- 효율성이 좋은 정렬은 아님



---

#### Topic5: 자료 중 가장 작은 것을 찾아 순서대로 정렬하는 방법은 무엇일까요?

> Keyword
>
> - 선택 정렬
> - 배열



**선택 정렬**

- 배열 안의 자료 중 가장 작은 수(혹은 가장 큰 수)를 찾아 첫 번째 위치(혹은 가장 마지막 위치)의 수와 교환해주는 방식의 정렬
- <u>교환 횟수를 최소화</u>하는 반면 각 자료를 비교하는 횟수는 증가



**실행**

<img src="https://user-images.githubusercontent.com/42233535/54760129-c9d89180-4c32-11e9-9986-04efabbcfa19.png">

<img src="https://user-images.githubusercontent.com/42233535/54760134-cba25500-4c32-11e9-8377-99d3382931e8.png">

​	1) 프로그램은 array라는 배열의 첫 번째 자리(5)에서 시작

​	2) **가장 작은 원소**를 찾기 위해 5를 (1, 6, 2, 4, 3)와 비교

​	3) 1이 가장 작은 값이기 때문에 5의 위치와 교환

​	4) 이제 1은 정렬되었으며 나머지 5, 6, 2, 4, 3은 여전히 정렬되지 않은 상태

​	5) 다음은 두 번째 자리(5)인데, 정렬되지 않은 오른쪽(6, 2, 4, 3)부분만 확인하면 됨

​	6) 2가 정렬되지 않은 배열의 원소 중 가장 작은 원소이므로 5와 자리를 바꿈

​	7) 이와 같은 방식으로 계속해서 비교와 교환을 반복

- n번째 정렬 전에 배열 정렬이 완료돼도(ex)step5) 끝까지 진행한 후 알고리즘 종료(컴퓨터는 알지 못함)



**정렬된 배열**

- 버블 정렬과는 다르게 몇 번의 교환을 해주었는지 횟수를 셀 필요가 없음
- 하지만 더 많은 비교가 필요하므로 비용이 많이 듦
- 선택 정렬로 정렬되는 배열은 **n-1번의 교환**이 필요
- 한 번의 교환을 위해서 정렬되지 않은 모든 수와 비교가 이루어져야 하므로 **n^2번의 비교**가 이루어짐
- 선택 정렬은 최선의 경우에도 최악의 경우에서 수행하는 횟수만큼 비교와 교환을 해주어야 함



---

#### Topic6: 정렬된 부분, 정렬되지 않은 부분 나누어 정렬하는 방법은 무엇일까요?

> Keyword
>
> - 삽입 정렬
> - 배열



**삽입 정렬**

- 자료가 정렬된 부분, 정렬되지 않은 부분으로 나누어짐
- **정렬되지 않은 부분의 자료가 정렬된 부분의 자리로 삽입**되는 형태의 정렬 방법



**실행**

<img src="https://user-images.githubusercontent.com/42233535/54761799-238e8b00-4c36-11e9-8f6b-af99255f6ce6.png">

<img src="https://user-images.githubusercontent.com/42233535/54761804-25f0e500-4c36-11e9-87db-73d4fb47fb0c.png">

- 1) 프로그램이 실행되었을 때, array라는 배열의  첫 번째 자리(5)는 이미 정렬된 부분이라고 간주

- 2) 정렬되지 않은 부분의 맨 앞 자리인 1은 5보다 작기 때문에 5는 오른쪽으로 이동하고 1이 첫 번째 자리로 옴
- 3) 다음으로 정렬되지 않은 부분의 6을 살펴봄
- 4) 6은 5보다 크기 때문에 이동할 필요가 없음
- 5) 같은 방식으로 계속 실행하면 전체 값이 모두 정렬



**정렬된 배열**

- 삽입 정렬은 특정 실행 단계에서, 어떤 원소가 정렬된 배열 내에 자리를 찾았다고 해서 그것이 최종적인 제자리라는 보장이 없음 -> 다음 단계에서 위치가 바뀔 수 있음
- 자료의 양이 적을 때 성능이 우수하며 자료 대부분이 이미 정렬되어있는 경우 효율적
- 이미 정렬된 자료에 새로운 자료를 삽입해야 하는 경우가 발생하면, 정렬된 자료들이 자리를 이동해야 하므로 안정성이 낮음



---

#### Topic7: 정렬 알고리즘의 효율성을 높이기 위해서는 무엇을 고려해야 할까요?

> Keyword
>
> - 시간 복잡도
> - Big-O 표기법
> - Big Ω



**시간 복잡도**

- <u>알고리즘을 수행할 때 걸리는 시간을 기준으로 효율성을 분석하는 것</u>
- 시간의 효율성 = 알고리즘에서 비교와 교환 등이 일어날 때 <u>연산자의 처리 횟수</u>가 적다
- 연산자의 처리 횟수가 적다 = 시간 복잡도가 낮다
- 시간 복잡도가 낮을수록, 연산자의 사용 횟수가 적을수록 효율성이 높은 알고리즘



**Big-O 표기법**

- 컴퓨터 과학에서 "대략"을 나타내는 공식적인 개념
- 시간 복잡도를 나타내는 표현
- 점근적 표기법
- 알고리즘 실행 시간의 상한



**Big Ω(omega) 표기법**

- 최선의 경우
- 알고리즘 실행 시간의 하한



<img src="https://user-images.githubusercontent.com/42233535/54860483-00f79180-4d5e-11e9-9b85-774a85e190e1.png">

---

#### Topic8: 많은 자료를 분해하고 다시 합쳐 정렬하는 것을 무엇이라고 할까요?

> Keyword
>
> - 합병 정렬
> - 분할 정복



**합병 정렬**

- 원소가 한 개가 될 때까지 계속해서 반으로 나누다가 다시 합쳐나가며 정렬하는 방식
- cf.) 전화번호부의 분할 정복 탐색
- 재귀적으로 구현



**실행**

<img src="https://user-images.githubusercontent.com/42233535/54928114-c442ba80-4f56-11e9-82ed-5516aa7650ca.png">

<img src="https://user-images.githubusercontent.com/42233535/54928464-44692000-4f57-11e9-9d55-710f14eb4664.png">

- 합병 정렬 = 배열의 원소들이 반으로 나누어지는 과정 + 정렬된 후 합쳐지는 과정
  - 1) 이 프로그램이 시작되면 6개의 원소를 가진 배열은 반으로 나뉘고, 원소가 1개가 될 때까지 계속해서 나누어짐
  - 2) step4와 같이 모든 원소가 1개가 되었을 때, 다시 합치면서 정렬이 이루어짐
  - 3) step4에서 5로 넘어가면서 3과 5의 크기를 비교하고 정렬된 채로 넘어가는 것처럼 나머지 나누어진 부분도 같은 방식으로 병합
- step4를 중심으로 나누어지고(step2, step3) 합쳐지는 과정(step5, step6)이 역순으로 이루어짐
- 나누어지고 합쳐지는 중간 단계의 배열을 임시로 저장하고 함수가 종료될 때까지 기억하고 있어야 하기 때문에, 메모리의 필요한 공간이 늘어남



**정렬된 배열**

- 분할 정복
  - 절반을 그리고 그 절반을 보는 방식으로 진행
  - 탐색 시간이 굉장히 짧음
- 합병 정렬의 시간 복잡도 = **Ο(n log n)**
  - n개의 원소가 있을 때 다 나누어지기까지 호출되는 함수의 개수 = log n
  - 합쳐지는 과정에서 각 원소들의 크기를 비교 = n번의 비교 과정





출처: [CS50 X edwith](https://www.edwith.org/cs50/)