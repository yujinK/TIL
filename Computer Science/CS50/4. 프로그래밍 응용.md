### 4. 프로그래밍 응용

#### Topic1: 프로그래밍 언어로 작성된 프로그램을 컴퓨터는 어떻게 이해할까요?

> Keyword
>
> - 컴파일
> - 컴파일러
> - 오브젝트 코드
> - 전처리
> - 어셈블
> - 링크



**컴파일 과정(Compile)**

- 컴파일
  - 소스 코드를 오브젝트 코드로 변환시키는 과정
    - 소스코드 : 프로그래밍 언어로 작성한 코드
    - 오브젝트 코드 : 기계어, 0과 1로 이루어져 있으며 컴퓨터에게 프로그램이 어떻게 실행되어야 하는지 알려주는 코드
- make 명령어 자체는 컴파일러가 아니고, clang이라는 컴파일러를 호출해서 C 소스 코드를 오브젝트 코드로 컴파일



<img src="https://user-images.githubusercontent.com/42233535/55339461-b0aacd00-54dd-11e9-90e6-c719089e2d70.png">

**전처리(Precompile)**

- 컴파일의 전체 과정은 네 단계, 그 중 첫 번째 단계 = 전처리
- 전처리기에 의해 수행
- #으로 시작되는 C 소스 코드는 전처리기에게 실질적인 컴파일이 이루어지기 전에 무언가를 실행하라고 알려줌



**컴파일(Compile)**

- 컴파일러 : C코드를 어셈블리어라는 저수준 프로그래밍 언어로 컴파일
- 어셈블리
  - C보다 연산의 종류가 훨씬 적지만, 여러 연산들이 함께 사용되면 C에서 할 수 있는 모든 것들을 수행할 수 있음
- C코드를 어셈블리코드로 변환시켜줌으로써 컴파일러는 컴퓨터가 이해할 수 있는 언어와 최대한 가까운 프로그램으로 만듦
- 컴파일이라는 용어는 소스 코드에서 오브젝트 코드로 변환하는 전체 과정을 통틀어 일컫기도 하지만, 구체적으로 전처리한 소스 코드를 어셈블리 코드로 변환시키는 단계를 말하기도 함





**어셈블(Assemble)**

- 어셈블리코드를 오브젝트 코드로 변환
- CPU가 프로그램을 어떻게 수행해야 하는지 알 수 있는 명령어 형태인 연속된 0과 1들로 바꾸는 작업
- 변환작업은 어셈블러가 수행
- 소스코드에서 오브젝트 코드로 컴파일 되어야 할 파일이 딱 한 개라면, 컴파일 작업은 여기서 종료. 그렇지 않은 경우 링크 단계 추가



**링크(Link)**

- 프로그램이 (math.h나 cs50.h 같은 라이브러리를 포함해) 여러 개의 파일로 이루어져 있어 하나의 오브젝트 파일로 합쳐져야 한다면 링크라는 컴파일의 마지막 단계가 필요
- 링커
  - 여러 개의 다른 오브젝트 코드파일을 실행 가능한 하나의 오브젝트 코드 파일로 합쳐줌

---

#### Topic3: 10을 4로 나누면 어떤 값이 나올까요?

> Keyword
>
> - 형변환
> - 명시적 형변환
> - 암묵적 형변환



**형변환(Typecasting)**

변수를 한 자료형에서 다른 자료형으로 변환

형변환할 때 정밀도(표현 범위)가 더 높은 자료형으로 바꿀 경우 값에 오차가 발생할 수 있다는 점을 유의



**명시적 형변환**

이미 존재하는 변수 앞에 새로운 자료형을 넣어 다른 자료형으로 바꿔주는 것

ex.) printf("%c\n", **(char)**x);



**암묵적 형변환**

ASCII 표준에 해당하는 정수를 %c에 전달하면 컴파일러는 그 값을 자동으로 문자로 해석

정수는 소수점 뒤의 숫자들에 대한 정보를 저장할 수 없기 때문에 float형인 값을 int형으로 변환하면 부동 소수점 수의 소수점 뒤를 버린 값을 저장함

ex.) printf("%c\n", **(char)**x); 에서 (char)를 쓰지 않아도 문자 A를 출력



------

#### Topic4: 자주 사용되는 기능을 다시 사용하는 방법이 있을까요?

> Keyword
>
> - 함수
> - 추상화
> - 매개변수
> - return
> - 지역변수
> - 전역변수



**함수**

- 특정 목적을 위해 만들어진 재사용 가능한 코드
- 입력값과 출력값을 가지며 프로그램 내의 어디서든 재사용 가능
- 프로그램을 여러 개의 함수로 만들면 코드를 조직화하고 간단하게 만들 수 있음 = **추상화**의 한 예



**범위(Scope)**

- 지역변수
  - 그 함수 안(지역)에서만 사용될 수 있고, 다른 곳에서는 존재하지 않음
  - 지역변수를 함수 외부에서 참조하려고 한다면, 컴파일러는 오류 발생
- 전역변수
  - 어떤 변수 영역 내에서도 접근할 수 있는 변수
  - 지역성이 없음

------

#### Topic5: 연속된 데이터를 효율적으로 처리하는 방법에는 무엇이 있을까요?

> Keyword
>
> - 배열
> - 문자열
> - 배열의 크기
> - 인덱스
> - 널 종단(\0)



**배열과 문자열**

- 배열
  - 같은 자료형으로 된 여러 개의 변수를 연속적으로 저장
- 문자열
  - 문자배열
  - 문자 값을 연속적으로 저장



**배열**

- 선언
  - 배열에 저장되는 자료의 유형을 명시
  - 배열의 이름 지정
  - 대괄호 안에 배열의 크기

<img src="https://user-images.githubusercontent.com/42233535/55598508-04dbd880-578e-11e9-8c67-a16b85a30b71.png">

- 숫자 인덱스
  - 배열 안에 들어있는 특정 값에 접근하기 위해 사용
  - 몇 번째 값인지 가리킴
  - 0부터 시작
- 배열의 각 값은 인덱스 숫자로 참조하기 때문에 배열을 반복문으로 돌리기 쉬움



**문자열**

- C에서 문자열은 char 값들의 배열
- C에서 문자열의 마지막 인덱스는 널(NULL)로 끝나며, '\0'으로 나타냄
- 널 종단(null-terminator)
  - 문자열이 끝났고 더 이상의 문자가 남아있지 않다고 말하는 문자

<img src="https://user-images.githubusercontent.com/42233535/55598558-42d8fc80-578e-11e9-8607-2540e0a1abde.png">

------

#### Topic6: 커맨드 라인에서 프로그램에 필요한 데이터를 전달할 수 있을까요?

> Keyword
>
> - 명령줄
> - 명령행 인자
> - argc
> - argv



**커맨드라인**

- 프로그램을 <u>명령줄(Command-line)</u>에서 실행시킬 때, 보통 **./프로그램_이름** 같은 명령어로 실행

- C에서는 프로그램의 <u>명령행 인자(command-line arguments)</u>들을 명시할 수 있고, **명령줄에 인자들을 명시하여 사용자가 프로그램의 main 함수에 인자들을 전해줄 수 있게 함**



**argc, argv**

- C에서 명령행 인자들을 main 함수에 입력값으로 전달
- argc (argument count)
  - 정수형
  - 명령줄에 전달되는 인자의 수
  - 공백으로 구분되는 각 단어는 하나의 인자로 인식
  - 프로그램을 호출하는 것도 인자로 인식
- argv (argument vector)
  - 인자들 그 자체를 나타내는 배열
  - 배열의 각 값은 문자열

<img src="https://user-images.githubusercontent.com/42233535/55600024-50de4b80-5795-11e9-95a1-4ba680bd2042.png">

------

#### Topic7: return 0은 어떤 의미를 가지고 있을까요?

> Keyword
>
> - 종료 코드
> - 입력 유효성
> - 디버깅



**종료 코드**

- main 함수가 반환하는 값
- main 함수 안에서 아무 것도 반환하지 않으면 기본적으로 <u>컴파일러는 자동으로 main 함수가 0을 반환한다고 추정</u>



**종료 코드 사용하기**

- 관례적으로, 프로그램이 문제없이 성공적으로 끝나면 종료 코드 0을 반환
- **0이 아닌 종료코드**(보통 1이나 -1)는 일반적으로 프로그램이 실행되는 동안 프로그램이 성공적으로 끝나지 못하게 하는 <u>어떤 오류가 있었다는 것</u>을 의미
- 흔히 **입력 유효성(input validation)** 과정에서 종료 코드 사용
  - 사용자가 제공한 입력값이 유효한지 프로그램이 확인하는 것



**종료 코드 확인하기**

- 명령줄로 프로그램을 실행시키면 main 함수가 반환하는 반환 값을 볼 수 없음
- <u>디버깅 도구</u>를 사용하면 main 함수가 어떤 종료 코드로 종료됐는지 볼 수 있음
  - 코드에서 어떤 문제가 있는지 찾을 수 있도록 도와주는 프로그램



---

#### Topic8: 누군가 미리 구현해둔 함수들을 사용한다면 편하지 않을까요?

> Keyword
>
> - 라이브러리
> - 헤더파일



**라이브러리**

프로그래머들이 이미 만들어진 코드를 다시 개발하지 않아도 되게 하고, 서로 함께 작업할 수 있도록 만들어주는 함수의 모음



**라이브러리 사용하기**

``````c
#include <stdio.h>
#include <math.h>
``````

- 라이브러리를 불러오기 위해서는 #include를 사용해 해당 라이브러리의 헤더 파일을 포함해주면 됨
- 라이브러리를 불러오면 라이브러리 함수들을 사용할 수 있음



**C에서 자주 쓰이는 라이브러리 함수**

**ctype.h** : 문자 분류 함수, 문자열 처리시 문자의 유형에 따라 구분해서 처리해야 하는 경우 사용하는 함수 라이브러리

**math.h** : 수학 관련 함수, 대부분의 수학 관련 함수는 double형의 인자를 갖고, double형의 값을 리턴

**stdlib.h** : 데이터 변환 함수, 데이터 변환 함수는 데이터 간의 형태 변환이 필요할 때 사용

**string.h** : 문자열 처리 함수, 하나 혹은 두 개의 문자열을 입력받아 문자열의 값을 처리



---

#### Topic9: 다양한 속성들을 가지는 나만의 자료형을 만들 수 있다면 유용하지 않을까요?

> Keyword
>
> - 구조체
> - 캡슐화
> - 추상화
> - 멤버



**구조체와 캡슐화**

- 캡슐화
  - 어떤 개체에 연관되는 정보들을 한 덩어리로 묶는 것
- 구조체(structure)
  - 여러 정보가 모여 한 개체를 이루게 하는 방법
  - ex.) 이름(string), 나이(int), 평점(float)이 모여 학생이라는 개체를 이룰 때



**배열과 구조체**

``````c
typedef struct
{
    string name;
    int year;
    float gpa;
}
student;
``````

- 구조체

  - 서로 다른 자료형의 변수를 하나로 묶어 새로운 자료형을 만들 수 있음
  - 각 정보들을 멤버라고 부름
  - 구조체 자료형의 특정 멤버 접근 방법
    - 구조체명.멤버명 (student.name)

- 구조체의 장점

  - 서로 다른 자료형의 데이터들을 하나로 묶을 수 있음
  - 크기를 미리 선언할 필요가 없음
  - 하지만 배열이 인덱스를 사용하여 각 멤버들을 순환하는 것과 달리 구조체는 멤버를 순환할 수 없음

  

**구조체 구현하기**

``````c
student s1 = {'Zamyla', 2014, 4.0};
s1.gpa = 3.5;
``````

---

#### Topic10: 반복문을 사용하지 않고, 반복해서 처리하는 기능을 구현할 수 있을까요?

> Keyword
>
> - 재귀
> - 스택



**재귀(Recursion)**

함수가 본인 스스로를 호출해서 사용



**재귀의 사용**

```c
int sigma(int n)
{
    if(n <1)
    {
        return 0;
    }
    
    int sum = 0;
    
    for(int i=1; i<=n; i++)
    {
        sum += i;
    }
    
    return sum;
}
```

```c
int sigma(int n)
{
    if(n <= 0)
    {
        return 0;
    }
    else
    {
        return (n + sigma(n-1));
    }
}
```

- 시그마
  - 주어진 수 n부터 1까지의 연속된 수를 모두 합한 값



**스택**

- 스택
  - <u>함수가 호출될 때 마다 사용되는 메모리</u>
- 재귀 함수에서 동일한 함수를 계속해서 호출될 때마다 함수를 위한 메모리가 계속 할당됨
- 운영체제는 함수를 실행할 수 있도록 일정량의 바이트를 주고, 그 공간에 함수의 변수나 다른 것들을 저장할 수 있도록 함
- 재귀 함수 사용 시 무한 호출될 경우 스택 공간은 초과되고 프로그램 충돌이 발생
- 재귀를 사용할 때는 과도하게 스택 메모리가 사용되지 않도록 주의
<img src="https://user-images.githubusercontent.com/42233535/55692103-c3426c00-59df-11e9-818a-b5ec8f7c65cf.png">







출처: [CS50 X edwith](https://www.edwith.org/cs50/)
