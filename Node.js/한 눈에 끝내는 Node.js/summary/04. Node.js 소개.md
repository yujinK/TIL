# Node.js 소개

## Node.js 란?

- 서버사이드 자바스크립트
- 구글의 자바스크립트 엔진인 V8을 기반으로 구성된 일종의 소프트웨어 시스템
- 이벤트 기반 개발 가능, Non-Blocking I/O 지원 -> 비동기식 프로그래밍 가능
- I/O 부하가 심한 대규모 서비스를 개발하기 적합
- 자바스크립트의 표준라이브러리 프로젝트인 CommonJS의 스펙을 따름    





### 노드의 탄생 배경

- 가장 널리 쓰이는 JSP나 PHP와 같은 언어로 웹 애플리케이션을 개발할 때 어떤 클라이언트가 웹 서버에 연결을 요청하게 된다면, 일정한 메모리 공간을 사용하여 새로운 쓰레드를 생성 -> 더 많은 사용자를 지원하기 위해 더 많은 서버 추가 + 서버 구매 비용, 운영 비용, 트래픽 비용, 인건비, 서버 데이터 동기화 등 문제 발생
- 이런 현실적인 문제를 해결하기 위해 등장한 것이 **노드**
  - 서버에서 클라이언트로부터의 요청, 즉 **`연결을 처리하는 방법을 새로운 컵셉으로 변경`**하여 이 문제를 해결
  - 기존에는 각 연결에 대해 새로운 쓰레드를 생성하고 그에 따라 메모리를 할당하여 사용자 요청을 처리했다면, 노드에서는 **`각 연결이 하나의 이벤트로서 노드 엔진에서 처리`**    





## 이벤트 기반 비동기 방식

- 노드가 뛰어난 성능을 발휘할 수 있는 이유
  - 비동기 이벤트 기반 아키텍처
  - 구글의 V8 자바스크립트 엔진    





### 쓰레드 기반 vs 비동기 이벤트 기반

- 대부분의 애플리케이션은 Blocking I/O를 사용 -> 멀티 쓰레드 사용
  - 개발자 입장에서는 직관적이고 멀티 태스킹을 위해 어쩔 수 없는 선택
  - 네트워크에서 동시에 대규모 요청을 동시에 처리하는 데에는 부적절    





### Blocking I/O

- 하나의 프로세스가 어떤 자원을 사용하고자 할 때 그 자원을 다른 프로세스가 점유하고 있다면, 그 프로세스가 그 자원의 사용을 끝마칠 때까지 기다려야 한다는 것

<img src="https://grm-project-template-bucket.s3.ap-northeast-2.amazonaws.com/lesson/les_dNOma_1488263111120/1488263625769_image.png">

- 먼저 애플리케이션이 운영체제의 커널에게 파일을 읽기 위해 시스템 콜이라는 형태로 요청을 보냄. 커널은 파일을 읽기 위한 동작을 수행하기 시작하고 애플리케이션은 커널이 파일을 다 읽을 때까지 기다려야 함. 일반적으로 이 상태를 애플리케이션이 **Blocked**되었다고 표현하며 이 시간 동안 실제로 애플리케이션은 아무것도 하지 않는 상태가 됨.    





### 멀티 쓰레드

- 쓰레드 여러 개가 동시에 실행되어 요청을 처리함

- CPU의 <u>시분할</u>이라는 개념으로 설명됨

  - 하나의 CPU를 여러 프로세스 또는 쓰레드가 시간을 나누어 동작하도록 함으로써 마치 CPU를 공유하여 사용하는 것과 같은 효과를 냄

  <img src="https://grm-project-template-bucket.s3.ap-northeast-2.amazonaws.com/lesson/les_dNOma_1488263111120/1488263996541_image.png">

  - 그림의 첫 번째 : 시분할을 이용하지 않고 `싱글 쓰레드`로 요청을 처리할 때의 모습
    - 먼저 들어 온 요청을 먼저 처리하고 이 요청에 대한 처리가 끝날 때까지 기다린 후에 다음 요청을 처리하는 식
    - 먼저 요청한 작업이 먼저 응답을 받을 수 있음
  - 그림의 두 번째 : `단순한 프로세스 스케줄링을 적용`한 경우
    - 특정 쓰레드가 일정 시간만 CPU를 사용할 수 있도록 되어 있음
    - 프로세스 C가 가장 늦게 요청을 했음에도 불구하고 가장 먼저 응답을 받을 수도 있음을 보여줌
  - 그림의 세 번째 : `CPU를 사용할 수 있는 시간이 더 적게 설정`됨
    - 두 번째와 마찬가지로 먼저 요청이 온 A보다 B가 먼저 작업을 마치고 응답을 할 수도 있는 모습을 보여줌    





### 쓰레드로 인해 발생하는 문제

- 멀티 쓰레드를 통해 복수의 요청으로 인해 발생하는 공유 문제는 해결 가능
- CPU 사용에 대해 스케줄링을 통해 멀티 쓰레딩을 하더라도 하나의 CPU를 다수의 쓰레드가 사용하고자 한다면, 결국 CPU 자체도 하나의 자원이기 때문에 여러 쓰레드들이 CPU를 점유하기 위해 기다릴 수밖에 없다는 점 -> 근본적인 문제
- 쓰레드를 기반으로 동작할 때 발생하는 실질적인 문제점
  - Blocking I/O 자체가 발생시키는 쓰레드 지연에 대한 문제
    - I/O 요청을 하고 응답이 올 때까지 아무것도 하지 않고 시간을 낭비
  - 스케줄링을 위한 처리 시간과 문맥 전환(Context switch) 비용 발생
    - 쓰레드를 분배하여 사용하기 위해 사용하는 스케줄링 그 자체도 CPU를 이용한 연산이 필요한 작업이고, 쓰레드 간의 전환을 위해서는 전환하기 직전의 쓰레드를 나중에 복귀시킬 때를 대비하여 그 상태를 저장해두어야 하는데, 이 또한 CPU를 이용한 연산이 필요한 작업
    - 쓰레드가 많아질수록 문맥전환에 따른 성능 저하 발생
      - 쓰레드들을 별도로 관리하거나, 더 작은 단위로 쪼개어 VM 등으로 실제 쓰레드로 분배하는 방식 같은 대안 등장 -> 문맥 전환에 드는 시간이 네이티브 CPU 쓰레드를 사용하는 것보다 더 적음    





### 싱글 쓰레드와 이벤트 기반의 비동기 I/O 처리

- 노드는 이러한 문제들은 `싱글 쓰레드`와 `이벤트 기반의 비동기 I/O 처리로 해결`하고 그 성능을 끌어올릴 수 있도록 하는 비동기 프로그래밍 모델을 제공
- 싱글 쓰레드를 가진 노드는 I/O 작업이 시작되면 I/O 작업 처리에 대한 응답을 기다리지 않고, **바로 다음 작업을 실행**
- 대신 I/O 작업이 종료되면 이벤트를 발생시키고, 이 이벤트는 해당 프로세스의 이벤트 큐에 등록됨
- 노드로 개발된 프로세스는 이 이벤트 큐에 등록된 새로운 이벤트를 감지하여, 해당 이벤트 시 수행하여야 할 작업을 실행    





### 이벤트 루프(Event Loop)

- 작업을 요청하면서 그 작업이 완료되었을 때 어떤 작업을 진행할지에 대한 콜백 함수를 지정하여 `동작이 완료되었을 때 해당 콜백 함수를 실행하는 방식의 동작 방식`
- 만약 클라이언트가 **웹 서버에 HTTP 형식으로 요청**하게 되면 서버에서는 **이벤트 루프가 계속 돌고 있다가** 이를 감지하고 알맞은 작업을 워커 쓰레드를 생성하여 실행. 이 때, 이벤트 루프는 해당 워커 쓰레드가 작업을 마친 뒤 그 결과와 함께 응답할 때까지 기다리는 것이 아니라 바로 루프로 복귀하여 다른 요청을 기다림.
- 이벤트 루프는 `어떤 요청이 발생하면 그 작업에 대한 쓰레드 실행`만을 일으킬 뿐. 이후 작업을 할당받았던 해당 쓰레드가 모든 작업을 마치면 미리 전달받은 콜백 함수를 실행하도록 이벤트 루프로 응답하게 되며 이벤트 루프는 이것을 실행하여 클라이언트에게 결과를 응답

<img src="https://grm-project-template-bucket.s3.ap-northeast-2.amazonaws.com/lesson/les_dNOma_1488263111120/1488269479578_image.png">





​    

## Node.js의 특징

### 자바스크립트 기반

- 기존 웹 애플리케이션에서 프론트엔드를 구성하는 대부분이 자바스크립트

  백엔드도 자바스크립트를 이용하여 개발

  = **프론트엔드와 백엔드가 자바스크립트라는 하나의 언어로 통일**

  - 프론트엔드와 백엔드가 좀 더 긴밀한 구조로 설계될 수 있음
  - 풀스택 개발 가능
  - 개발 단계에서나 유지보수 단계에서 시간, 인력을 줄일 수 있음
  - 코드 통합이 쉬워짐
  - JSON과 같은 공통 데이터 포맷도 프론트엔드와 백엔드 사이에서 쉽게 사용    





### 이벤트 기반의 프로그래밍 모델

- 기존에 프론트엔드 개발에서 <u>jQuery</u>라는 자바스크립트 라이브러리가 널리 사용
  - 이벤트 기반의 비동기 처리 방식으로 개발 가능
- jQuery가 익숙한 개발자들에게 이벤트 기반의 프로그래밍 모델을 가진 노드는 백엔드 개발에 매력적    





### NPM을 통한 다양한 확장 모듈들

- 노드는 확장성이 뛰어난 모듈 구조를 가짐 -> 기본 모듈 이외에 다양한 확장 모듈 사용 가능
- NPM : 설치 관리자
  - <u>확장 모듈</u>을 쉽게 설치
    - 노드의 보급에 큰 영향    





## Node.js의 아키텍쳐

<img src="https://grm-project-template-bucket.s3.ap-northeast-2.amazonaws.com/lesson/les_kVVqd_1533200523344/056fbc6066a6b4f3379325043c03eb39c44d77e90196df7900de98044c4708cc.png">

- 노드는 C/C++과 자바스크립트로 만들어짐
  - 대부분은 자바스크립트
  - C/C++은 레이어와 시스템 통합을 위해 사용
- 구글이 만든 V8 자바스크립트 엔진 위에서 동작
  - V8 엔진 구조는 개발자들이 각자의 목적에 맞게 만든 노드 프로그램이 그 라이브러리 위에서 동작할 수 있게 해줌
  - '소켓'이나 'HTTP 프로토콜'을 사용해 데이터를 송수신하는 기능을 포함
- 위의 사진은 초창기의 아키텍처로, 기술이 발전하며 노드 0.9부터는 libev의 종속성을 제거
  - libeio와 libev를 libuv로 대체

<img src="https://grm-project-template-bucket.s3.ap-northeast-2.amazonaws.com/lesson/les_kVVqd_1533200523344/a0049d4b85d55ac50c8825c2ab88410bb55b321322f05b232af3341477d78d9b.png">

- 노드 표준 라이브러리(Node standard library)
  - 실직적으로 V8과 연결되어 특정 기능들을 수행할 수 있도록 도와주는 자바스크립트 기본 라이브러리
  - 자바스크립트 언어로 작성
  - 노드 바인딩과 연경
- 노드 바인딩(Node Bindings)
  - C/C++로 구성된 시스템 바인딩 레이어
  - C/C++로 작성된 라이브러리를 자바스크립트에서 사용할 수 있도록 결합하는 핵심 요소
  - 소켓, http 등의 통신 기능이 제공되지만, DOM에 관한 기능은 제공하지 않음
  - 소켓이나 http 등에 대한 노드 바인딩이 노드 표준 라이브러리와의 인터페이스 역할
- V8 엔진
  - 구글에서 개발된 오픈소스 JIT 가상머신 형식의 자바스크립트 엔진
  - 구글 크롬 브라우저에 내장되어 있지만 독립적으로 실행 가능
  - C++로 작성된 응용 프로그램의 일부로 작동 가능
  - 노드는 이 엔진을 이용하여 자바스크립트로 개발된 노드 애플리케이션을 동작시킴
- 쓰레드 풀(thread pool)
  - libeio라는 비동기 I/O 라이브러리로 구성
  - 파일 관련 작업 수행 (read, write, open, close, stat, unlink, fdatasync, mknod, readdir 등의 작업)
  - 이벤트 기반의 모든 게 비동기로 동작하는 C언어용 I/O 라이브러리
  - 노드에서 비동기 입출력 작업들은 모두 이 라이브러리로 동작
  - Node.js도 싱글 쓰레드만 사용하는 것이 아니라 내부적으로 멀티 쓰레드 풀을 사용하기는 함
- 이벤트 루프(event loop)
  - libev를 이용하여 구성
  - 다양한 기능을 가진 고성능 이벤트 루프 라이브러리
  - libevent라는 라이브러리와 유사 (노드의 이벤트 루프가 이것으로 구성)

- C-ares
  - 동시에 복수의 DNS 질의 요청을 비동기적으로 처리하기 위한 C 라이브러리